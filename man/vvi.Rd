% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vvi.R
\name{vvi}
\alias{vvi}
\title{Viewshed Visibility Index (VVI) from sf}
\usage{
vvi(
  observer,
  dsm_rast,
  dtm_rast,
  max_distance = 200,
  observer_height = 1.7,
  spacing = NULL,
  mode = c("VVI", "cumulative", "viewshed"),
  by_row = FALSE,
  cores = 1L,
  progress = FALSE
)
}
\arguments{
\item{observer}{An `sf` object containing the observer locations. Each observer location should be a point geometry with a defined coordinate reference system (CRS).}

\item{dsm_rast}{A `SpatRaster` object representing the Digital Surface Model (DSM) of the area, indicating the elevation of surface objects including vegetation, buildings, and other features.}

\item{dtm_rast}{A `SpatRaster` object representing the Digital Terrain Model (DTM) of the area, indicating the elevation of the ground surface without any objects.}

\item{max_distance}{The maximum distance (in meters) from the observer location within which the greenspace visibility is calculated. Default is 200 meters.}

\item{observer_height}{The height (in meters) of the observer above the ground level. Default is 1.7 meters.}

\item{spacing}{optional; numeric > 0; Only if \code{observer} is a LINESTRING or POLYGON. Points on the line will be generated. The \code{spacing} parameter sets the distance in between the points on the line/grid. Defaults to the resolution of the \code{dsm_rast}.}

\item{mode}{A character string specifying the type of decay function to apply to the visibility weights. Options are "VVI", or "viewshed". Default is "VVI".}

\item{by_row}{logical; Only relevant if observer is not a POINT feature and only for \code{mode = c("VVI", "cumulative")}. See details for more information. Default is FALSE.}

\item{cores}{The number of cores to use for parallel processing. This parameter is relevant only if the function is set to run in parallel. Default is 1.}

\item{progress}{logical; Show progress bar and computation time?}
}
\value{
`sf` or `SpatRaster` object. See details for more information.
}
\description{
The VVI expresses the proportion of visible area to the total area based on a viewshed (\code{\link[CGEI]{viewshed_list}}).
The estimated VVI values range between 0 and 1, where 0 = no cells within the buffer is visible, and 1 = all of the cells are visible.
}
\details{
\code{observer} needs to be a geometry of type POINT, LINESTRING, MULTILINESTRING, POLYGON or MULTIPOLYGON. If observer is a LINESTRING or MULTILINESTRING, 
points will be generated along the line(s) every \code{spacing} meters. If \code{observer} is a POLYGON or MULTIPOLYGON, a grid with resolution = \code{spacing} 
will be generated, and VVI will be computed for every point. The CRS (\code{\link[sf]{st_crs}}) needs to have a metric unit!

\itemize{
\item{\code{mode = "VVI"}\cr}{\itemize{
\item{\code{by_row = FALSE}\cr}{Returns a `sf` object containing the VVI values as POINT features, where 0 = no visible cells, and 1 = all of the cells are visible.}
\item{\code{by_row = TRUE}\cr}{Returns a `sf` object containing the VVI for each row of the observer feature in its original geometry.}
}} 
\item{\code{mode = "cumulative"}\cr}{\itemize{
\item{\code{by_row = FALSE}\cr}{Returns the Cumulative Viewshed Visibility Index (CVVI); A single number indicating the cumulative proportion of cells that are visible from at least one observer point inside the area determined by the union of all observer points buffered by `max_distance`.}
\item{\code{by_row = TRUE}\cr}{Returns the Cumulative Viewshed Visibility Index (CVVI) for each row of the observer features in its original geometry.}
}} 
\item{\code{mode = "viewshed"; Returns a `SpatRast` with two layers:}\cr}{\itemize{
\item{\code{n_views}\cr}{Counts how many times each cell is visible across all viewsheds. This layer identifies cells with high visibility across the landscape.}
\item{\code{view_per_viewshed}\cr}{Calculates the ratio of the number of viewsheds in which a cell is visible to the total number of potential viewsheds for that cell.}
}}}
}
\examples{
\dontrun{
library(sf)
library(terra)

# Simulate observer locations as sf points
observer <- st_as_sf(data.frame(lon = c(5, 5.1), lat = c(52, 52.1)),
                      coords = c("lon", "lat"), crs = 4326)

# Transform to UTM zone 31N for metric units
observer <- st_transform(observer, 32631)

# Create synthetic rasters for DSM, DTM, and greenspace around observers
# This is a simplified example assuming flat terrain and random greenspaces
bbox_observer <- st_bbox(observer)
x_range <- bbox_observer[c("xmin", "xmax")]
y_range <- bbox_observer[c("ymin", "ymax")]

# Create a raster with 1km x 1km around the observer
dsm_rast <- rast(res=100,
                 xmin=min(x_range)-1000, xmax=max(x_range) + 1000, 
                 ymin=min(y_range)-1000, ymax=max(y_range) + 1000, 
                 crs=crs(observer))
dsm_rast[] <- runif(ncell(dsm_rast), 0, 1.5) # Assign random heights

dtm_rast <- rast(dsm_rast, vals=0) # Flat terrain

# Calculate VGVI
vvi_results <- vvi(observer, dsm_rast, dtm_rast)
}

}
